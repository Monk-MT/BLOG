# 算法整理

## 1. 两数之和

### 从数组中找到两个数和为 target

使用 HashMap，依次遍历，先查找再添加

## 2. 两数相加

### 两逆序链表相加

依次相加即可

## 3. 无重复字符的最长字串

### 找出字符串中无重复字符的最长字串

HashMap + 滑动窗口

## 4. 寻找两个正序数组的中位数

1. 先排序合并，再找
2. 各切半，左多 1，长随短动

## 5. 最长回文字串

中心扩散法 + 剪枝

## 6. Z 字形变换

### 把字符串按给定行数以从上往下、从左到右进行 Z 字形排列

index 循环加减，字符依次拿取，放入对应的 sb 中

## 10. 正则表达式匹配

动态规划 (i, j) 代表 s 串前 i 和 p 串前 j 匹配。非 \* 直接判断当前，\* 则有不出现和出现多次的情况

## 11. 盛最多水的容器

### 找 min(num[i], num[j]) * (j - i) 的最大值

双指针，两端向中间，小的先走

## 15. 三数之和

### 找到数组中三个不同的数相加等于 target

排序 + 双指针（两端到中间）

## 17. 电话号码的字母组合

### 九宫格键盘，按下数字键对应的字母的组合

预先建立数字和字母对应的 Map，回溯法输出组合

## 19. 删除链表的倒数第 N 个结点

双指针，先走 N + 1 个，再一起走，删除后指针的下一个。针对恰好 N 长链表优化

## 20. 有效的括号

入栈出栈

## 21. 合并两个有序链表

依次插入

## 22. 括号生成（n 对）

递归 dfs (String s, int left, int right)，保持左小于右

## 23. 合并 K 个升序链表

对未排序链表头维护一个从小到大的优先队列

## 31. 下一个排列

### 将给定数字序列重新排列成字典序中下一个更大的排列

两遍扫描（步骤）

1. 从后往前找出第一个小于后一个数个数 change（坐标 i），没有则直接反转排列
2. 有则从 change 从前往后找到恰好大于 change 的数
3. 交换两数
4. 反转 i 之后的排列

## 32. 最长有效括号

动态规划 dp[n]，记录以下标 i 字符结尾的最长有效括号的长度

## 33. 搜索旋转排序数组

二分发，多二分后的数组是否有序的判断

## 34. 在排序数组中查找元素的第一个和最后一个位置

1. 先二分找到目标，再左右找头尾
2. 二分找查找第一个大于等于 target 的下标，和查找第一个大于 target 的下标再减一

## 39. 组合总和

### 找出数组中可以使数字和为 target 的组合（可重复选取）

回溯，递归中循环从当前节点开始

## 42. 接雨水

### 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水

1. 单调栈（栈顶小），横向计算
2. 动态规划统计当前位置左右的最大高度，竖向计算
3. 双指针 两边向中间，竖向计算

## 46. 全排列

### 对不含重复数字的数组全排列

回溯

## 48. 旋转图像

### 将 n 维矩阵顺时针旋转 90°

1. 先水平翻转，再对角线翻转
2. 直接旋转

```Java
int temp = matrix[i][j];
matrix[i][j] = matrix[n - j - 1][i];
matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
matrix[j][n - i - 1] = temp;
```

## 49. 字母异位词分组

### 对字符串数组中字母相同，但排列不同的字符串分组

对每个字符串排序，```HashMap<String, List<String>>``` 判断相似并添加

## 53. 最大子序和

count 统计和，数组依次添加并计算 max，count 为负时重置为 0

## 55. 跳跃游戏

### 数组中的每个元素代表你在该位置可以跳跃的最大长度，判断你是否能够到达最后一个下标

依次遍历，判断能否跳到，并维护一个最远跳跃距离

## 56. 合并区间

### 给区间数组，合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间

按照左区间大小排序，依次合并即可

## 62. 不同路径

### 从 m x n 的网格的左上角走到右下角的路径

动态规划，(i,j) 为左上角到当前点的路径数量

## 64. 最小路径和

### 从 m x n 的数组的左上角走到右下角的路径中，所有数字和最小的路径

动态规划，(i,j) 为左上角到当前点的最小路径和

## 70. 爬楼梯

### 每次走 1 或 2，有多少种方法到 n

动态规划，到 i 有多少种方法，没个位置之和前两个位置相关

## 72. 编辑距离

### 计算 字符串 1 转换到 字符串 2 的最小操作数

动态规划，(i,j) 为 A(0,i-1) 转换为 B(0,j-1) 的最小操作数 (A 增，A 减，A 换）

公式：
min(f(i-1,j-1),f(i,j-1)+1,f(i-1,j)+1), (A(i-1) == B(j-1))
min(f(i-1,j-1),f(i-1,j),f(i,j-1)) + 1, (A(i-1) != B(j-1))

## 75. 颜色分类

### 把三色乱序数组，按照 1，2，3 排列

三指针，遍历指针，1 指针从前往后，3 指针从后往前

## 76. 最小覆盖字串

### 返回 s 中涵盖 t 所有字符的最小子串

HashMap 存 t + 滑动窗口（不满足 t 左边加，满足后右边减找最小直到不满足）

## 78. 子集

### 返回数组的所有子集

回溯

## 79. 单词搜索

## 二维字符数组中查找字符能否连起来组成目标单词

暴力查找 + 回溯（查找过先改为#，再改回）

## 81. 搜索旋转排序数组Ⅱ

### 数组中有重复数字

二分法，多二分后的数组是否有序的判断，多左边和中间是否相同的判断

## 84. 柱状图中最大的矩形

单调栈（栈顶大）

## 85. 最大矩形

### 0、1 组成的二维数组中，1 组成的最大矩形

按每行 1 的高度转换为柱状图中最大矩形（84 题）

## 94. 二叉树的中序遍历

左中右，维护栈

## 96. 不同的二叉搜索树

动态规划，i 个节点的组合数。dp[i] 为左右子树组合数之积

## 98. 验证二叉搜索树

维护一个节点数字能出现的区间，递归

## 101. 对称二叉树

递归即可

## 102. 二叉树的层序遍历

节点队列和层数队列同步

## 104. 二叉树的最大深度

递归，返回时依次加一

## 105. 从前序与中序遍历序列构造二叉树

递归

## 114. 二叉树展开为线序遍历链表

左子树的最右节点和右子树根节点连接

## 121. 买卖股票的最佳时机

### 数组记录股票交易价格，只能买卖一次，找最大利润

从左到右遍历，维护到当前节点为止的最大最小值，并以此计算股票价值

## 124. 二叉树中的最大路径和

### 寻找二叉树中任意路径中和最大的路径，不一定通过根节点

后续遍历，递归，最大值在（左反 + 当前 + 右反）中产生，返回 max（左反 + 当前，右反 + 当前）

## 125. 最长连续序列

### 从乱序数组中任意取数字，组成的数字连续的最长序列

把所有数放入 HashSet 中，遍历数组，set 中查找和该数连续的数并移除，统计长度

## 136. 只出现一次的数字

异或所有数字

## 139. 单词拆分

### 判定字符串是否可以被空格拆分为一个或多个在字典中出现的单词

使用 HashSet 存放单词，动态规划 i 处存从 0 到 i 的字串能否被拆分

## 141. 环形链表

### 判断链表是否有环

1. 快慢指针
2. HashSet 存储

## 142. 环形链表Ⅱ

### 找环形链表的入环位置

1. 快慢指针：先判断环，快指针指向头，慢不动，两都一次一格，交点即为头
2. HashSet 存储，第一个重复即为头

## 146. LRU 缓存机制

使用 LinkedHashMap

## 148. 排序链表

归并排序

## 152. 乘积最大子数组

### 数组中乘积最大的连续子数组

动态规划（常数化），i 处记录以 i 结尾的最大连续子数组和最小连续子数组

## 155. 最小栈

### 能在常数时间内检索到最小元素的栈

两个栈，一个维护常规出入栈，另一个维护最小值（和常规栈同出入，但只存当前最小值）

## 160. 相交链表

### 找出并返回两个单链表相交的起始节点

获取两链表长度，长先走，直到剩下长度相同时，两同时走并判断

## 169. 多数元素

### 在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素

计数，先第一个元素，出现一次+1，否则-1，到零则换当前元素。遍历到最后的元素即为多数元素

## 198. 打家劫舍

### 给定一个非负整数数组，计算你**不连续取两个数**的情况下，能取到的总值最大

动态规划（常数化），i 处代表前 i 个数中能取到的最大值，dp[i]=max(dp[i−2]+nums[i],dp[i−1])

## 200. 岛屿数量

### 二维数组中由 1 组成的岛屿（被 0 包围，只能横竖扩展）的数量

需要修改数据。从每个 1 开始深度遍历，0 则返回，1 则改 0 后继续遍历。一次完整遍历为 1 个岛屿

## 206. 反转链表

头插法

## 207. 课程表

使用 List 建图，深度遍历图，标记已经访问了的节点

## 208. 实现 Trie（前缀树）

每个节点有一个 26 长的数组用来存放该字母对应的节点，一个结束标记用来该节点是否为单词的最后一个字母。

## 215. 数组中的第 K 个最大元素

1. 堆排序
2. 快排 + 截枝

## 221. 最大正方形

### 0，1 组成的二维数组中，相邻 1 组成的最大正方形

动态规划，(i,j) 为以 (i,j) 为右下角的最大正方形的边长，dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1

## 226. 翻转二叉树

左右互换

## 234. 回文链表

计算长度，翻转前半部分，判断前后是否相等，再次翻转前半部分

## 236. 二叉树的最近公共祖先

全局变量记录公共祖先，找到子节点则返回 1，两个 1 则为公共祖先，则记录并返回 0

## 238. 除自身以外数组的乘积

先从左到右乘，再从右到左乘

## 239. 滑动窗口最大值

使用 ArrayDeque 维护最大值，左大右小

- 滑入时，右边出队，直到大于滑入值，滑入值入队
- 滑出时，左边和滑出值相同则出队
- 该窗口的最大值为队列最左端

## 240. 搜索二维矩阵Ⅱ

### 从上至下，从左至右升序的二维数组中查找目标值

从左下角查起，先减行，再加列

## 279. 完全平方数

### 用最少个完全平方数组合成 target

动态规划，i 处为组成该数的最少平方数和，f[i] = 1 + f[i - j * j], (1 < j < √i)

## 283. 移动零

### 将数组中 0 移动至末尾，同时保证其他元素相对顺序

依次遍历，统计其他元素需要向前移动的位数，移动其他元素，末尾直接改为 0

## 287. 寻找重复数

### 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有一个重复的整数 ，找出这个重复的数

1. 把该数组看作图，可知该图一定有环，即可使用链表找环头的方法
2. 二分法，看 mid 的值和下标的偏移方向
3. 统计二进制位 1 的个数和不重复时比较，因为只有 1 个重复，则重复的会多 1

## 297. 二叉树的序列化与反序列化

可用层序遍历

## 300. 最长递增子序列

1. 动态规划，i 处位以 i 为结尾的递增子序列的最大长度，dp[i]=max(dp[j])+1, 其中 0≤j<i 且 num[j]<num[i]

2. 贪心 + 二分查找，维护一个数组 d，依次把原数组 nums 中的数添加到 d，只有 nums[i] > d[len] 时插入到 d 的末尾且 len++；其他时候皆为替换正好大于 nums[i] 的数，查找替换位置时使用二分